
*******************************************************************************
* The following .include lines are necessary for all your CSCI 50.02 JSim
* exercises. These work like your Java import statement.
*******************************************************************************

.include "8clocks.jsim"
.include "nominal.jsim"
.include "stdcell.jsim"


*******************************************************************************
* subcircuit definitions
*******************************************************************************

.subckt fa a b c_in sum c_out
  Xsub1 a b f nand2
  Xsub2 a f g nand2
  Xsub3 b f h nand2
  Xsub4 g h x nand2

  Xsub5 x c_in i nand2
  Xsub6 x i j nand2
  Xsub7 c_in i k nand2
  Xsub8 j k sum nand2

  Xsub9 f i c_out nand2
.ends

* The above code uses the full adder circuit from lab 2 which uses 4-NAND gate implementation
* for the XOR gate parts of a full adder circuit. In a 32-bit full adder, the c_in of one full adder
* takes the output of the c_out of the full adder before it as its input.

* c_in affects i and k. 
* c_out is caused by f and i. 

* The delay comes from cases where i is triggered which happens to be during [0, 1, 1] and [1, 0, 1]
* In other words, the delay occurs in cases where the c_in and c_out wait on each other for input.

* This effect is well documented as a consequence of using a ripple carry adder, where the ripple - 
* in other words the cumulative propagation delay - is caused by the carry bits having to "ripple" back through
* the rest of the circuit for the addition to be completed. (Additional explanation during defense)

*******************************************************************************
* explanation of definition and instantiation of 32 bit adder
*
* a3-2-1-0 = a[31:0]
* b3-2-1-0 = b[31:0]
* c_in0 c_out(0-1)-(0-1)-0 = c_in0 c_out[31:30] c_out31
* sum3-2-1-0 = sum[31:0]
* c_out(1-0)-(1-0) = c_out[31:30]#16
* fa = .subckt fa a b c_in sum c_out
*******************************************************************************

.subckt add32 a[31:0] b[31:0] c_in0 sum[31:0] c_out[31:30]
  Xadd a[31:0] b[31:0]  c_out[30:0] c_in0 
  + sum[31:0] c_out[31:0] fa
.ends

* The above iterates the instantiation of 32 connected fa circuits
* to form a 32-bit adder.

Xsum a[31:0] b[31:0] 0 sum[31:0] c31 c30 add32

* The above code instantiates where to plot the sums of the 32-bit adder.

*******************************************************************************
* implementation of digital waveforms for testing
*******************************************************************************

Wa a[31:0] nrz(0, 5, 20ns, 0ns, 0.001ns, 0.001ns)
  + 0x00000000 0x55555555 0x00000000 0x55555555 0xFFFFFFFF 
  + 0xAAAAAAAA 0x00000000 0xAAAAAAAA 0x00000001 0xFFFFFFFF

Wb b[31:0] nrz(0, 5, 20ns, 0ns, 0.001ns, 0.001ns)
  + 0x00000000 0x00000000 0x55555555 0x55555555 0xFFFFFFFF 
  + 0x00000000 0xAAAAAAAA 0xAAAAAAAA 0xFFFFFFFF 0x00000001

* The above code tests the sums of the given test cases and shows their respective
* results via the sum[31:0] plot below (also showing the transition delays).
* The above uses hexadecimal inputs for a and b respectively, but JSIM
* automatically outputs the results of the waveform in hexadecimal when plotted.

.tran 300ns
.plot a[31:0]
.plot b[31:0]
.plot sum[31:0]


